<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Pod::Advent 0.21 (Pod::Simple 3.14, Perl::Tidy 20090616) on 2010-12-23 18:13:13 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>2010 Perl Advent Calendar: Mojolicious::Lite 和 WebSocket</title>
<link rel="stylesheet" href="../style.css" type="text/css" />
<link rel="alternate" type="text/plain" href="websocket.pod" />
</head>
<body>
<h1><a href="../">Perl Advent Calendar 2010-12</a>-24</h1>
<h2 align="center">Mojolicious::Lite 和 WebSocket</h2>
<h3 align="center">by cnhackTNT</h3>
<h3><tt><a href="http://search.cpan.org/perldoc?Mojolicious">Mojolicious</a></tt></h3>
<p>CGI 时代，Web 曾是 Perl 的天下，刚接触 Perl 时通宵写一个留言本的兴奋感一回头尤在昨夜，然而这些年，PHP、Python、Ruby 等的崛起带来了 Web 开发框架的百花齐放，Ruby on Rails 的出现更把 Web2.0 简洁轻灵之美的特性带给了幕后的工程师们。作为一名 Perl 爱好者，当我敲下 <span style="font-style: italic">cpan Catalyst</span> 后面对满屏的依赖，测试耗去半个小时甚至更久的时候，很难说我对玩 Rails 或是 Django 的程序员不心存嫉妒－尤其是当出现 <span style="font-style: italic">make test: Failed</span> 的时候。</p>
<p><tt><a href="http://search.cpan.org/perldoc?Catalyst">Catalyst</a></tt> 很好，可是它太重了，哪怕是最简单的 Hello World，Catalyst 服务器跑起来在我不算落后的机器上也要等上好几秒，但是不能否认它对 Perl 社区的重要性，我认为它是第一个把 MVC <span style="font-weight: bold">清晰</span>地带给 Perl 社区并且功能完整的框架，它也吸收很很多其他语言框架的优秀特性，可是凭心而论，它对初学者算不上友好。</p>
<p>Catalyst 的种种弊端让它的主要开发者之一 <span style="font-style: italic">Sebastian Riedel</span> 跳出来开始了 <tt>Mojolicious</tt> 这个项目，他希望 Mojolicious 在保留 Catalyst 优点的同时，摒弃复杂的模块依赖，融合更多方便 Web 开发者的特性，做到开箱即用。</p>
<p><tt><a href="http://search.cpan.org/perldoc?Mojolicious::Lite">Mojolicious::Lite</a></tt> 是基于 <tt>Mojolicious</tt> 的一个轻量级框架，本文不会讨论 Mojolicious 本身，你可以通过 <tt><a href="http://search.cpan.org/perldoc?Mojolicous::Lite">Mojolicous::Lite</a></tt> 模块的文档学习如何快速上手，我们这里要介绍的是该模块一个有趣的地方，即它支持的 <span style="font-style: italic">WebSocket</span>。</p>
<h3>什么是 WebSocket</h3>
<p>接触过网络编程的同学肯定对 <span style="font-style: italic">Sockets</span> 不陌生，那 <a href="http://www.whatwg.org/specs/web-socket-protocol/">WebSocket</a> 是个什么东东？</p>
<p><span style="font-style: italic">WebSocket</span> 是基于 TCP 的一个独立的协议，如果 Web 服务器和客户端都支持该协议，那么 Web 应用程序就可以基于此协议进行双向通讯，典型的应用场景便是 Web 聊天室，Web 股票行情实时推送，实时多人 Web 协作平台，Web 网游等。</p>
<p>以 Web 股票行情系统为例，在 <span style="font-style: italic">WebSocket</span> 出现以前的做法无非下面几种：</p>
<p>- 页面通过 HTML 标签或是 Javascript 定时向 Web 服务器发起新请求，获得新的股票行情数据。</p>
<p>- 通过在网页中内嵌 Flash/ActiveX/Java Applet 插件程序来实现服务器端到客户浏览器的数据推送。</p>
<p>- 通过 Ajax 或是隐藏的 <span style="font-style: italic">iframe</span> 和服务器建立长连接，即通过 Long Polling 来模拟推送，这种方式也被称为 <span style="font-style: italic">Comet</span> 技术，也是时下流行的做法。</p>
<p>这些做法存在一些问题：</p>
<p>- 定时刷新的方式会造成对服务器的频繁请求。</p>
<p>- 插件的方式需要客户端相应平台支持。</p>
<p>- 通过 HTTP 长连接这种方式并不是真正的双向交互，它仍然需要发起多次请求来实现双向交互，而且每次客户端对服务器的请求都得包含 HTTP 头信息，服务器还得解析这些信息，资源上有浪费。</p>
<p>所以 <a href="http://www.whatwg.org/">WHATWG</a> 提出了 <a href="http://www.whatwg.org/specs/web-socket-protocol/">WebSocket</a>，并起草了协议标准提交给了 <a href="http://www.ietf.org/">IETF</a>。</p>
<p>通过 <span style="font-style: italic">WebSocket</span>，便可以在单个 TCP 连接上进行双向通讯，另外关键的是，<span style="font-style: italic">WebSocket</span> 的握手过程对目前支持 <a href="http://tools.ietf.org/html/rfc2616">HTTP/1.1</a> 的主流 Web 服务器来说即是 <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42">HTTP Upgrade</a> 请求，并且 <span style="font-style: italic">WebSocket</span> 默认使用 80 或 443 端口，分别对应着 HTTP 和 HTTPS 的默认端口。</p>
<p>市面上支持 HTML5 的浏览器如 Chrome 8，Opera 11，Safari 5，Firefox 4 均支持 <span style="font-style: italic">WebSocket</span>。</p>
<p>浏览器通过 <span style="font-style: italic">WebSocket</span> 进行通讯的过程类似这样：</p>
<p>1. 客户端浏览器向 Web 服务器发起 <span style="font-style: italic">WebSocket</span> 握手请求</p>
<p>2. 服务器解析客户端浏览器发来的请求，通过 HTTP 的 <span style="font-style: italic">Upgrade</span> 头获知这是一个 <span style="font-style: italic">WebSocket</span> 请求，于是从客户端发来的数据获取相应的 Key 进行计算，并准备好其它数据返回给客户端浏览器，完成握手。</p>
<p>3. 握手完成后，浏览器和客户端便可遵循 <span style="font-style: italic">WebSocket</span> 协议双向互发数据了。</p>
<p>协议的具体内容可以参看：<a href="http://www.whatwg.org/specs/web-socket-protocol/">http://www.whatwg.org/specs/web-socket-protocol/</a></p>
<p><span style="font-style: italic">WebSocket</span> 的 API 可以参看：<a href="http://www.w3.org/TR/websockets/">http://www.w3.org/TR/websockets/</a></p>
<h3>Mojolicious::Lite 和 WebSocket</h3>
<p>从上面的信息中我们可以知道，无论是客户端还是服务器端都是需要支持 <span style="font-style: italic">WebSocket</span> 才可以使用它来进行通讯的，而 <tt>Mojolicious::Lite</tt> 已经内置了对 <span style="font-style: italic">WebSocket</span> 的支持，因此我们可以通过它来开发支持 <span style="font-style: italic">WebSocket</span> 的 Web 应用程序，是不是非常酷？</p>
<p><tt>Mojolicious::Lite</tt> 提供了名为 <span style="font-style: italic">websocket</span> 的方法让使用者能将特定的 <span style="font-style: italic">WebSocket</span> 请求关联到处理程序，如：</p>
<pre><span class="c">websocket '/say' => sub {
    my $self = shift;
    warn "User connected!\n";

    $self->finished( sub { warn "User disconnected!\n" } );
    
    $self->on_message( sub {
        my ($self, $message) = @_;
        $self->send_message( "You said: $message" );
    });


}</span></pre>
<p><span style="font-style: italic">$self-&gt;finished(sub {...});</span> 指定了当客户端连接断开时，程序该做什么处理;</p>
<p><span style="font-style: italic">$self-&gt;on_message(sub {...});</span> 指定了当客户端发来信息时，程序该做什么处理；</p>
<p><span style="font-style: italic">$self-&gt;send_message("...");</span> 用来从服务器程序向客户端发送消息。</p>
<p>上面示例中的代码指定当客户端发起 <span style="font-style: italic">WebSocket</span> 请求到服务器的 <span style="font-style: italic">/say</span> 这个路径的时候，如果是刚建立连接，则服务器在控制台输出 <span style="font-style: italic">"User connected!"</span>；</p>
<p>如果客户端断开连接，则调用 <span style="font-style: italic">finished()</span> 中定义的匿名子程序在控制台输出 <span style="font-style: italic">"User disconnected!"</span>；</p>
<p>如果客户端有消息发来，则调用 <span style="font-style: italic">on_message()</span> 中定义的匿名子程序，将 <span style="font-style: italic">"You said: "</span> 加上客户端发来的消息，通过 <span style="font-style: italic">send_message()</span> 方法发给客户端。</p>
<p>于是通过 <span style="font-style: italic">on_message()</span> 和 <span style="font-style: italic">send_message()</span> 方法，服务器端的 Web 应用程序便可以和客户端进行 <span style="font-style: italic">WebSocket</span> 通讯了。</p>
<h3>应用举例</h3>
<p>举个例子来玩玩吧，比如说手边有一台升级到 iOS4.2 的 iPod Touch，我想将 <a href="http://www.flickr.com">Flickr</a> 和目前比较火的 <a href="http://instagr.am/">Instagram</a> 上最新的图片推送到我的 iPod Touch 自带的浏览器中， 但是不巧的是我本地访问这两个网站非常慢，怎么办呢？</p>
<p>恰好还有台中间主机A， 我从 iPod Touch 上访问 A 速度很快，并且从 A 上访问上面提到的两个网站也非常快，于是我们可以用 <tt>Mojolicious::Lite</tt> 在主机 A 上建立一个 Web 应用程序，抓取这两个网站上的新图片，并通过 <span style="font-style: italic">WebSocket</span> 推送到 iPod Touch 的浏览器中。</p>
<p>代码可以在我的 <a href="https://github.com/cnhacktnt/demos/tree/master/websockets">Github 仓库</a>中找到，里面也使用到了<a href="http://advent.perlchina.org/2010/scoreboard.html">之前介绍的 Parallel::Scoreboard 模块</a> 和 <span style="font-style: italic">fork</span>。</p>
<p>当然这里用 <tt><a href="http://search.cpan.org/perldoc?Parallel::Scoreboard">Parallel::Scoreboard</a></tt> 和 <span style="font-style: italic">fork</span> 纯粹只是为了和之前的文章有所关联，加深印象，好玩而已，我们可以直接用 <tt><a href="http://search.cpan.org/perldoc?Mojo::Client">Mojo::Client</a></tt> 模块来并发抓取 Flickr 和 Instagram 的图片，并且还是非阻塞的。</p>
<p>有问题可以发邮件到 cnhacktnt 在 gmail 的邮箱，或者 @cnhacktnt （你懂的） :-)</p>
<p>谢谢!</p>
<div style="float: right; font-size: 10pt"><a href="websocket.pod">View Source (POD)</a></div><br />
</body>
</html>
