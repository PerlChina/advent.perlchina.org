<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Pod::Advent 0.24 (Pod::Simple 3.14, Perl::Tidy 20101217) on 2011-12-24 16:40:10 -->
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>2011 Perl Advent Calendar: Solve root directory space problem with Perl</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="../style.css" type="text/css" />
<link rel="alternate" type="text/plain" href="solve_root_dir_space.pod" />
</head>
<body>
<h1><a href="../">Perl Advent Calendar 2011-12</a>-24</h1>
<h2 align="center">Solve root directory space problem with Perl</h2>
<h3 align="center">by Joe Jiang</h3>
<p>如果说 Windows 系统有 DLL 地狱的话，看上去无限美好的 CPAN 其实也有 Dependency 问题，如果你试过安装高依赖性模块应该深有体会。</p>
<p>对于 Unix 系统管理员来说，文件系统的挂接点如果不好好规划，也会有一个目录树挂载地狱。</p>
<p>问题是：如果有一天根目录空间紧张，那么如何找到最应该清理的目录呢？</p>
<p>因为 /proj 目录虽然是隶属于根目录磁盘的，但是 /proj/mounted 却可能是一个挂载点，或者更可怕的是挂载点在 /proj/mounted1/mounted2 这样的位置。</p>
<p>下面的脚本能帮忙找到根目录最大的消费者目录：</p>
<pre>
    <span class="i">% sudo</span> <span class="w">perl</span> -<span class="w">MList::MoreUtils</span>=<span class="w">any</span> -<span class="w">lne</span> <span class="q">&#39;BEGIN{@m=map {@F=split; qq(^$F[2])} map {$1 if m{(.*)}} qx{mount|tail --line=+2}; open STDIN, q(find / -maxdepth 3 -mindepth 1 |)} $p=$_; do {print join qq(\t), qx(du -s &quot;$_&quot;)=~m{(.*)}} unless any {$p=~m{$_} or $_=~m{$p}} @m&#39;</span> | <span class="k">sort</span> -<span class="w">k1</span> -<span class="w">nrg</span> | <span class="w">head</span>
</pre>

<p>它会通过调用 mount | tail --line=+2 来分析哪些目录是挂载点，然后调用 find / -maxdepth 3 ... 来列出根目录下三级内的所有的文件和目录。然后逐个调用 du -s 来分析目录或文件的大小，并滤掉所有挂载点，最后用 sort 排序输出。</p>
<p>希望你能进一步定制它，使得这个脚本适合你的需要。</p>
<div style="float: right; font-size: 10pt"><a href="solve_root_dir_space.pod">View Source (POD)</a></div><br />
</body>
</html>
